<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
        替罪羊与KDTree - Arahc&#39;s blog
      </title>
        <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    
    <meta name="theme-color" content="#000000" />
    
    <meta http-equiv="window-target" content="_top" />
    
    
    <meta name="description" content="前言 替罪羊树是一种平衡树。对于平衡树的二叉搜索树性质，已经在这个博客比较详细地提到过了。那篇博客内，详细讲了的平衡树是 Splay。注意到 Splay 维护平衡的时候会直接通过旋转改变树的结构，在写平衡树套什么东西的时候，Splay 维护起来可能会有写吃力。因此这里重点写一下替罪羊树。
KD-Tree 和替罪羊树维护树平衡的方法一样，因此也可以提出来讲讲。
其实重点是KD不是替罪羊
替罪羊树 平衡树的插入，删除等操作基本都是一致的，重要的是如何维护树的平衡。例如给出一个不太平衡的树：
虽然单次查询不至于退化成 $\operatorname{O}(n)$，但相对 $\log$ 的级别也够慢了。我们发现比较不平衡的两个典型，就是 $10$ 和 $64$ 的两个子树。
替罪羊树的思想很简单，现在既然这两个地方不平衡，那我直接把这两个子树重建一下就可以了。
平衡多了。但是众所周知，我不能每次修改一下就要全部重新把不平衡的地方重建。为了保证复杂度，应该需要衡量一个平衡因子 $\alpha$，其中 $\alpha\in(0.5,1)$，如果一个节点的左右子树中，较大的那个子树占比达到了 $\alpha$，就给这个子树重构一下。合适的 $\alpha$ 可以控制替罪羊树的复杂度。
一般而言，$\alpha$ 取到 $[0.65,0.75]$ 就够了。如果你的 $\alpha$ 取到了 $0.9$ 才能保证不出锅，多半就是写假了。没有写假、平衡因子设置合理的替罪羊树单次操作复杂度基本 $\log$ 级。
具体的重构实现，可以先把要重构的子树拍扁，即按照中序遍历得到对应的序列，然后对于这个序列重新构建子树即可。每次重新构建的时候，应该以中位数对应的节点当作根节点，因为前面是在替罪羊树上中序遍历得到的序列，已经有序了，直接取中间位置就是中位数。
和 Splay 不同的地方还有替罪羊的删除操作。替罪羊树并不能很好地直接删除，因此通常以打标记的方法，如果这个数字被删掉了（出现次数为 $0$），在下一次重构的时候碰到这个点就不管它了。如果写的简单一点也可以直接忽视删除操作，保留原节点，大部分情况都不会被卡。
具体细节可以参考如下代码：
struct SheepTree{ int root,tot,tmp; int pb[max_n]; // 记录拍扁时的中序遍历数组 	SheepTree(){root=tot=tmp=0;} const double alpha=0.75; struct dot{ int ls,rs,sz,cnt,sd,sm,val; // 左右儿子、sz、出现次数、sd、sm、维护的值 	dot(){ls=rs=sz=cnt=sd=sm=val=0;} }a[max_n]; #define ls(x) (a[x].ls) 	#define rs(x) (a[x]." />
    <meta name="generator" content="Hugo 0.91.2 with theme pure" />
    <title>替罪羊与KDTree - Arahc&#39;s blog</title>
    
    
    <link rel="stylesheet" href="https://walker68145/Arahc.github.io/css/style.min.e64d754037c0ee0ec4e20ab1d6f07740ace61729bc03850559b8caa21ae4a597.css">
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css" async>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" async>
    <meta property="og:title" content="替罪羊与KDTree" />
<meta property="og:description" content="前言 替罪羊树是一种平衡树。对于平衡树的二叉搜索树性质，已经在这个博客比较详细地提到过了。那篇博客内，详细讲了的平衡树是 Splay。注意到 Splay 维护平衡的时候会直接通过旋转改变树的结构，在写平衡树套什么东西的时候，Splay 维护起来可能会有写吃力。因此这里重点写一下替罪羊树。
KD-Tree 和替罪羊树维护树平衡的方法一样，因此也可以提出来讲讲。
其实重点是KD不是替罪羊
替罪羊树 平衡树的插入，删除等操作基本都是一致的，重要的是如何维护树的平衡。例如给出一个不太平衡的树：
虽然单次查询不至于退化成 $\operatorname{O}(n)$，但相对 $\log$ 的级别也够慢了。我们发现比较不平衡的两个典型，就是 $10$ 和 $64$ 的两个子树。
替罪羊树的思想很简单，现在既然这两个地方不平衡，那我直接把这两个子树重建一下就可以了。
平衡多了。但是众所周知，我不能每次修改一下就要全部重新把不平衡的地方重建。为了保证复杂度，应该需要衡量一个平衡因子 $\alpha$，其中 $\alpha\in(0.5,1)$，如果一个节点的左右子树中，较大的那个子树占比达到了 $\alpha$，就给这个子树重构一下。合适的 $\alpha$ 可以控制替罪羊树的复杂度。
一般而言，$\alpha$ 取到 $[0.65,0.75]$ 就够了。如果你的 $\alpha$ 取到了 $0.9$ 才能保证不出锅，多半就是写假了。没有写假、平衡因子设置合理的替罪羊树单次操作复杂度基本 $\log$ 级。
具体的重构实现，可以先把要重构的子树拍扁，即按照中序遍历得到对应的序列，然后对于这个序列重新构建子树即可。每次重新构建的时候，应该以中位数对应的节点当作根节点，因为前面是在替罪羊树上中序遍历得到的序列，已经有序了，直接取中间位置就是中位数。
和 Splay 不同的地方还有替罪羊的删除操作。替罪羊树并不能很好地直接删除，因此通常以打标记的方法，如果这个数字被删掉了（出现次数为 $0$），在下一次重构的时候碰到这个点就不管它了。如果写的简单一点也可以直接忽视删除操作，保留原节点，大部分情况都不会被卡。
具体细节可以参考如下代码：
struct SheepTree{ int root,tot,tmp; int pb[max_n]; // 记录拍扁时的中序遍历数组 	SheepTree(){root=tot=tmp=0;} const double alpha=0.75; struct dot{ int ls,rs,sz,cnt,sd,sm,val; // 左右儿子、sz、出现次数、sd、sm、维护的值 	dot(){ls=rs=sz=cnt=sd=sm=val=0;} }a[max_n]; #define ls(x) (a[x].ls) 	#define rs(x) (a[x]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://walker68145/Arahc.github.io/posts/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E4%B8%8Ekdtree/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-25T21:48:19+08:00" />
<meta property="article:modified_time" content="2021-11-25T21:48:19+08:00" />

<meta itemprop="name" content="替罪羊与KDTree">
<meta itemprop="description" content="前言 替罪羊树是一种平衡树。对于平衡树的二叉搜索树性质，已经在这个博客比较详细地提到过了。那篇博客内，详细讲了的平衡树是 Splay。注意到 Splay 维护平衡的时候会直接通过旋转改变树的结构，在写平衡树套什么东西的时候，Splay 维护起来可能会有写吃力。因此这里重点写一下替罪羊树。
KD-Tree 和替罪羊树维护树平衡的方法一样，因此也可以提出来讲讲。
其实重点是KD不是替罪羊
替罪羊树 平衡树的插入，删除等操作基本都是一致的，重要的是如何维护树的平衡。例如给出一个不太平衡的树：
虽然单次查询不至于退化成 $\operatorname{O}(n)$，但相对 $\log$ 的级别也够慢了。我们发现比较不平衡的两个典型，就是 $10$ 和 $64$ 的两个子树。
替罪羊树的思想很简单，现在既然这两个地方不平衡，那我直接把这两个子树重建一下就可以了。
平衡多了。但是众所周知，我不能每次修改一下就要全部重新把不平衡的地方重建。为了保证复杂度，应该需要衡量一个平衡因子 $\alpha$，其中 $\alpha\in(0.5,1)$，如果一个节点的左右子树中，较大的那个子树占比达到了 $\alpha$，就给这个子树重构一下。合适的 $\alpha$ 可以控制替罪羊树的复杂度。
一般而言，$\alpha$ 取到 $[0.65,0.75]$ 就够了。如果你的 $\alpha$ 取到了 $0.9$ 才能保证不出锅，多半就是写假了。没有写假、平衡因子设置合理的替罪羊树单次操作复杂度基本 $\log$ 级。
具体的重构实现，可以先把要重构的子树拍扁，即按照中序遍历得到对应的序列，然后对于这个序列重新构建子树即可。每次重新构建的时候，应该以中位数对应的节点当作根节点，因为前面是在替罪羊树上中序遍历得到的序列，已经有序了，直接取中间位置就是中位数。
和 Splay 不同的地方还有替罪羊的删除操作。替罪羊树并不能很好地直接删除，因此通常以打标记的方法，如果这个数字被删掉了（出现次数为 $0$），在下一次重构的时候碰到这个点就不管它了。如果写的简单一点也可以直接忽视删除操作，保留原节点，大部分情况都不会被卡。
具体细节可以参考如下代码：
struct SheepTree{ int root,tot,tmp; int pb[max_n]; // 记录拍扁时的中序遍历数组 	SheepTree(){root=tot=tmp=0;} const double alpha=0.75; struct dot{ int ls,rs,sz,cnt,sd,sm,val; // 左右儿子、sz、出现次数、sd、sm、维护的值 	dot(){ls=rs=sz=cnt=sd=sm=val=0;} }a[max_n]; #define ls(x) (a[x].ls) 	#define rs(x) (a[x]."><meta itemprop="datePublished" content="2021-11-25T21:48:19+08:00" />
<meta itemprop="dateModified" content="2021-11-25T21:48:19+08:00" />
<meta itemprop="wordCount" content="786">
<meta itemprop="keywords" content="数据结构," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="替罪羊与KDTree"/>
<meta name="twitter:description" content="前言 替罪羊树是一种平衡树。对于平衡树的二叉搜索树性质，已经在这个博客比较详细地提到过了。那篇博客内，详细讲了的平衡树是 Splay。注意到 Splay 维护平衡的时候会直接通过旋转改变树的结构，在写平衡树套什么东西的时候，Splay 维护起来可能会有写吃力。因此这里重点写一下替罪羊树。
KD-Tree 和替罪羊树维护树平衡的方法一样，因此也可以提出来讲讲。
其实重点是KD不是替罪羊
替罪羊树 平衡树的插入，删除等操作基本都是一致的，重要的是如何维护树的平衡。例如给出一个不太平衡的树：
虽然单次查询不至于退化成 $\operatorname{O}(n)$，但相对 $\log$ 的级别也够慢了。我们发现比较不平衡的两个典型，就是 $10$ 和 $64$ 的两个子树。
替罪羊树的思想很简单，现在既然这两个地方不平衡，那我直接把这两个子树重建一下就可以了。
平衡多了。但是众所周知，我不能每次修改一下就要全部重新把不平衡的地方重建。为了保证复杂度，应该需要衡量一个平衡因子 $\alpha$，其中 $\alpha\in(0.5,1)$，如果一个节点的左右子树中，较大的那个子树占比达到了 $\alpha$，就给这个子树重构一下。合适的 $\alpha$ 可以控制替罪羊树的复杂度。
一般而言，$\alpha$ 取到 $[0.65,0.75]$ 就够了。如果你的 $\alpha$ 取到了 $0.9$ 才能保证不出锅，多半就是写假了。没有写假、平衡因子设置合理的替罪羊树单次操作复杂度基本 $\log$ 级。
具体的重构实现，可以先把要重构的子树拍扁，即按照中序遍历得到对应的序列，然后对于这个序列重新构建子树即可。每次重新构建的时候，应该以中位数对应的节点当作根节点，因为前面是在替罪羊树上中序遍历得到的序列，已经有序了，直接取中间位置就是中位数。
和 Splay 不同的地方还有替罪羊的删除操作。替罪羊树并不能很好地直接删除，因此通常以打标记的方法，如果这个数字被删掉了（出现次数为 $0$），在下一次重构的时候碰到这个点就不管它了。如果写的简单一点也可以直接忽视删除操作，保留原节点，大部分情况都不会被卡。
具体细节可以参考如下代码：
struct SheepTree{ int root,tot,tmp; int pb[max_n]; // 记录拍扁时的中序遍历数组 	SheepTree(){root=tot=tmp=0;} const double alpha=0.75; struct dot{ int ls,rs,sz,cnt,sd,sm,val; // 左右儿子、sz、出现次数、sd、sm、维护的值 	dot(){ls=rs=sz=cnt=sd=sm=val=0;} }a[max_n]; #define ls(x) (a[x].ls) 	#define rs(x) (a[x]."/>

    <!--[if lte IE 9]>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
      <![endif]-->

    <!--[if lt IE 9]>
        <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
      <![endif]-->
  </head>

  
  

  <body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/Walker_68145" target="_blank">
            <img class="img-circle img-rotate" src="https://walker68145/Arahc.github.io/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">Arahc</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">Arahc&#39;s home</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>Changsha, China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="Type something..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/Arahc.github.io/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">Home</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/Arahc.github.io/posts/">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">Archives</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/Arahc.github.io/categories/">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">Categories</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/Arahc.github.io/tags/">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">Tags</span>
                </a>
            </li>
            <li class="menu-item menu-item-about">
                <a href="/Arahc.github.io/about/">
                    <i class="icon icon-cup-fill"></i>
                  <span class="menu-title">About</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>

<aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>博客已经由 Walker_68145.github.io 转移到此处，原页面保留，为此带来的不便请大家谅解。</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> Tags</h3>
    <div id="tag-cloud-list" class="widget-body">
            
            
            <a href="https://walker68145/Arahc.github.io/tags/k%E8%BF%9B%E5%88%B6/" class="tag-list-link" rel="1">k进制<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/stl/" class="tag-list-link" rel="1">stl<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E4%BA%8C%E5%88%86%E4%B8%89%E5%88%86/" class="tag-list-link" rel="2">二分三分<span
               class="tag-list-count">2</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E5%88%86%E6%B2%BB/" class="tag-list-link" rel="3">分治<span
               class="tag-list-count">3</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="tag-list-link" rel="8">动态规划<span
               class="tag-list-count">8</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E5%9B%BE%E8%AE%BA/" class="tag-list-link" rel="7">图论<span
               class="tag-list-count">7</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="tag-list-link" rel="1">字符串<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E6%95%B0%E5%AD%A6/" class="tag-list-link" rel="10">数学<span
               class="tag-list-count">10</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="tag-list-link" rel="9">数据结构<span
               class="tag-list-count">9</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E6%9A%B4%E5%8A%9B/" class="tag-list-link" rel="4">暴力<span
               class="tag-list-count">4</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E8%8E%AB%E9%98%9F/" class="tag-list-link" rel="1">莫队<span
               class="tag-list-count">1</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E8%B4%AA%E5%BF%83/" class="tag-list-link" rel="3">贪心<span
               class="tag-list-count">3</span></a>
            
            
            <a href="https://walker68145/Arahc.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/" class="tag-list-link" rel="2">随机化<span
               class="tag-list-count">2</span></a>
            
    </div>
<script>
document.onreadystatechange = () => {
  if (document.readyState === 'complete') {
    tagCloud('#tag-cloud-list a',  8 ,  20 );
  }
};

function tagCloud(where, min, max) {
  let iMax = 0;
  let iMin = 0;
  $(where).each(function() {
    let weight = Number($(this).attr("rel"));
    if(iMax < weight) iMax = weight;
    if(iMin > weight || iMin == 0) iMin = weight;
  });
  let step = (max - min)/(iMax - iMin);
  $(where).each(function() {
    let weight = $(this).attr("rel") - iMin;
    $(this).css({"font-size": min + (weight * step) + 'px'});
  });
};
</script>
</div>

      <div class="widget">
    <h3 class="widget-title"> Categories</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://walker68145/Arahc.github.io/categories/%E6%9D%82%E9%A1%B9/" class="category-list-link">杂项</a><span class="category-list-count">3</span></li>
            <li class="category-list-item"><a href="https://walker68145/Arahc.github.io/categories/%E7%AC%94%E8%AE%B0/" class="category-list-link">笔记</a><span class="category-list-count">11</span></li>
            <li class="category-list-item"><a href="https://walker68145/Arahc.github.io/categories/%E9%A2%98%E8%A7%A3/" class="category-list-link">题解</a><span class="category-list-count">20</span></li>
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> Tags</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/k%E8%BF%9B%E5%88%B6/" class="tag-list-link">k进制</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/stl/" class="tag-list-link">stl</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E4%BA%8C%E5%88%86%E4%B8%89%E5%88%86/" class="tag-list-link">二分三分</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E5%88%86%E6%B2%BB/" class="tag-list-link">分治</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="tag-list-link">动态规划</a><span
                    class="tag-list-count">8</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E5%9B%BE%E8%AE%BA/" class="tag-list-link">图论</a><span
                    class="tag-list-count">7</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="tag-list-link">字符串</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E6%95%B0%E5%AD%A6/" class="tag-list-link">数学</a><span
                    class="tag-list-count">10</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="tag-list-link">数据结构</a><span
                    class="tag-list-count">9</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E6%9A%B4%E5%8A%9B/" class="tag-list-link">暴力</a><span
                    class="tag-list-count">4</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E8%8E%AB%E9%98%9F/" class="tag-list-link">莫队</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E8%B4%AA%E5%BF%83/" class="tag-list-link">贪心</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://walker68145/Arahc.github.io/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/" class="tag-list-link">随机化</a><span
                    class="tag-list-count">2</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://walker68145/Arahc.github.io/posts/p5633%E6%9C%80%E5%B0%8F%E5%BA%A6%E9%99%90%E5%88%B6%E7%94%9F%E6%88%90%E6%A0%91-%E9%A2%98%E8%A7%A3/" class="title">P5633最小度限制生成树 题解</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2021-12-28 21:43:22 &#43;0800 CST" itemprop="datePublished">2021-12-28</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://walker68145/Arahc.github.io/posts/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%85%A5%E9%97%A8/" class="title">线性基入门</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2021-12-22 21:47:24 &#43;0800 CST" itemprop="datePublished">2021-12-22</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://walker68145/Arahc.github.io/posts/markdown-%E5%85%A5%E9%97%A8/" class="title">Markdown 入门</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2021-11-30 18:41:00 &#43;0800 CST" itemprop="datePublished">2021-11-30</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://walker68145/Arahc.github.io/posts/oi-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E5%88%87%E9%A2%98%E5%86%85%E5%AE%B9/" class="title">OI 相关的非切题内容</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2021-11-28 21:42:04 &#43;0800 CST" itemprop="datePublished">2021-11-28</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://walker68145/Arahc.github.io/posts/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E4%B8%8Ekdtree/" class="title">替罪羊与KDTree</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2021-11-25 21:48:19 &#43;0800 CST" itemprop="datePublished">2021-11-25</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <h4 class="toc-title">Catalogue</h4>
    <nav id="toc" class="js-toc toc">

    </nav>
  </div>
</aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/Arahc.github.io/posts/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E4%B8%8Ekdtree/"
    >替罪羊与KDTree</a
  >
</h1>

      <div class="article-meta">
        
<span class="article-date">
  <i class="icon icon-calendar-check"></i>&nbsp;
<a href="https://walker68145/Arahc.github.io/posts/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E4%B8%8Ekdtree/" class="article-date">
  <time datetime="2021-11-25 21:48:19 &#43;0800 CST" itemprop="datePublished">2021-11-25</time>
</a>
</span>
<span class="article-category">
  <i class="icon icon-folder"></i>&nbsp;
  <a class="article-category-link" href="/Arahc.github.io/categories/%E7%AC%94%E8%AE%B0/"> 笔记 </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>&nbsp;
    <a class="article-tag-link" href="/Arahc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"> 数据结构 </a>
  </span>

		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 786 words</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Time: 4 minutes </span>
      </div>
    </div>
    <div class="article-entry marked-body js-toc-content" itemprop="articleBody">
      <h2 id="前言">前言</h2>
<p>替罪羊树是一种平衡树。对于平衡树的二叉搜索树性质，已经在<a href="https://walker68145.github.io/post/cong-er-cha-sou-suo-shu-dao-splay/">这个博客</a>比较详细地提到过了。那篇博客内，详细讲了的平衡树是 Splay。注意到 Splay 维护平衡的时候会直接通过旋转改变树的结构，在写平衡树套什么东西的时候，Splay 维护起来可能会有写吃力。因此这里重点写一下替罪羊树。</p>
<p>KD-Tree 和替罪羊树维护树平衡的方法一样，因此也可以提出来讲讲。</p>
<p><del>其实重点是KD不是替罪羊</del></p>
<h2 id="替罪羊树">替罪羊树</h2>
<p>平衡树的插入，删除等操作基本都是一致的，重要的是如何维护树的平衡。例如给出一个不太平衡的树：</p>
<p><img src="https://pic.imgdb.cn/item/619f987a2ab3f51d913f7fc0.png" alt=""></p>
<p>虽然单次查询不至于退化成 $\operatorname{O}(n)$，但相对 $\log$ 的级别也够慢了。我们发现比较不平衡的两个典型，就是 $10$ 和 $64$ 的两个子树。</p>
<p>替罪羊树的思想很简单，现在既然这两个地方不平衡，那我直接把这两个子树重建一下就可以了。</p>
<p><img src="https://pic.imgdb.cn/item/619f99cb2ab3f51d91403a04.png" alt=""></p>
<p>平衡多了。但是众所周知，我不能每次修改一下就要全部重新把不平衡的地方重建。为了保证复杂度，应该需要衡量一个平衡因子 $\alpha$，其中 $\alpha\in(0.5,1)$，如果一个节点的左右子树中，较大的那个子树占比达到了 $\alpha$，就给这个子树重构一下。合适的 $\alpha$ 可以控制替罪羊树的复杂度。</p>
<p>一般而言，$\alpha$ 取到 $[0.65,0.75]$ 就够了。如果你的 $\alpha$ 取到了 $0.9$ 才能保证不出锅，多半就是写假了。没有写假、平衡因子设置合理的替罪羊树单次操作复杂度基本 $\log$ 级。</p>
<p>具体的重构实现，可以先把要重构的子树拍扁，即按照中序遍历得到对应的序列，然后对于这个序列重新构建子树即可。每次重新构建的时候，应该以中位数对应的节点当作根节点，因为前面是在替罪羊树上中序遍历得到的序列，已经有序了，直接取中间位置就是中位数。</p>
<p>和 Splay 不同的地方还有替罪羊的删除操作。替罪羊树并不能很好地直接删除，因此通常以打标记的方法，如果这个数字被删掉了（出现次数为 $0$），在下一次重构的时候碰到这个点就不管它了。如果写的简单一点也可以直接忽视删除操作，保留原节点，大部分情况都不会被卡。</p>
<p>具体细节可以参考如下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SheepTree</span>{
	<span style="color:#66d9ef">int</span> root,tot,tmp;
	<span style="color:#66d9ef">int</span> pb[max_n]; <span style="color:#75715e">// 记录拍扁时的中序遍历数组
</span><span style="color:#75715e"></span>	SheepTree(){root<span style="color:#f92672">=</span>tot<span style="color:#f92672">=</span>tmp<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;}
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.75</span>;
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dot</span>{
		<span style="color:#66d9ef">int</span> ls,rs,sz,cnt,sd,sm,val; <span style="color:#75715e">// 左右儿子、sz、出现次数、sd、sm、维护的值
</span><span style="color:#75715e"></span>		dot(){ls<span style="color:#f92672">=</span>rs<span style="color:#f92672">=</span>sz<span style="color:#f92672">=</span>cnt<span style="color:#f92672">=</span>sd<span style="color:#f92672">=</span>sm<span style="color:#f92672">=</span>val<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;}
	}a[max_n];
	<span style="color:#75715e">#define ls(x) (a[x].ls)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">#define rs(x) (a[x].rs)
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resize</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x){
		a[x].sz<span style="color:#f92672">=</span>a[ls(x)].sz<span style="color:#f92672">+</span>a[rs(x)].sz<span style="color:#f92672">+</span>(<span style="color:#66d9ef">bool</span>)(a[x].cnt); <span style="color:#75715e">// sz 去掉删掉的点的子树大小
</span><span style="color:#75715e"></span>		a[x].sd<span style="color:#f92672">=</span>a[ls(x)].sd<span style="color:#f92672">+</span>a[rs(x)].sd<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 直接统计节点数的子树大小（数重复出现算一次）
</span><span style="color:#75715e"></span>		a[x].sm<span style="color:#f92672">=</span>a[ls(x)].sm<span style="color:#f92672">+</span>a[rs(x)].sm<span style="color:#f92672">+</span>a[x].cnt; <span style="color:#75715e">// 统计子树对应了实际上的多少个数（重复出现算多次）
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">regain</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x){ <span style="color:#75715e">// 判断需不需要重构
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>a[x].sm) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 被删掉了
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> (alpha<span style="color:#f92672">*</span>a[x].sd<span style="color:#f92672">&lt;=</span>max(a[ls(x)].sd,a[rs(x)].sd) <span style="color:#f92672">||</span> alpha<span style="color:#f92672">*</span>a[x].sd<span style="color:#f92672">&gt;=</span>a[x].sz);<span style="color:#75715e">// 子树不平衡，或者删掉了比较多的点影响平衡
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">int</span> x){ <span style="color:#75715e">// 中序遍历得到拍扁序列
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(ls(x)) get(ls(x));
		<span style="color:#66d9ef">if</span>(a[x].cnt) pb[<span style="color:#f92672">++</span>tmp]<span style="color:#f92672">=</span>x;
		<span style="color:#66d9ef">if</span>(rs(x)) get(rs(x));
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r){ <span style="color:#75715e">// 建树（重构）
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(l<span style="color:#f92672">==</span>r){
			ls(pb[l])<span style="color:#f92672">=</span>rs(pb[l])<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
			resize(pb[l]);
			<span style="color:#66d9ef">return</span> pb[l];
		}
		<span style="color:#66d9ef">int</span> mid<span style="color:#f92672">=</span>(l<span style="color:#f92672">+</span>r)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 取中间位置对应的节点，重造
</span><span style="color:#75715e"></span>		ls(pb[mid])<span style="color:#f92672">=</span>rs(pb[mid])<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) ls(pb[mid])<span style="color:#f92672">=</span>build(l,mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 读取左右儿子关系
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&gt;=</span>mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) rs(pb[mid])<span style="color:#f92672">=</span>build(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,r);
		resize(pb[mid]);
		<span style="color:#66d9ef">return</span> pb[mid]; <span style="color:#75715e">// 返回当前子树的根节点
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rebuild</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x){ <span style="color:#75715e">// 重构树的全流程
</span><span style="color:#75715e"></span>		tmp<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
		get(x); <span style="color:#75715e">// 中序遍历
</span><span style="color:#75715e"></span>		x<span style="color:#f92672">=</span>build(<span style="color:#ae81ff">1</span>,tmp); <span style="color:#75715e">// 重构这个点的子树
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pushup</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x){ <span style="color:#75715e">// 更新节点
</span><span style="color:#75715e"></span>		resize(x); <span style="color:#75715e">// 更新大小等信息
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(regain(x)) rebuild(x); <span style="color:#75715e">// 如果需要则重构
</span><span style="color:#75715e"></span>	}
    <span style="color:#75715e">// 剩下的都是板子了
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x,<span style="color:#66d9ef">int</span> val){
		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>x){
			x<span style="color:#f92672">=++</span>tot;
			a[x].val<span style="color:#f92672">=</span>val,a[x].cnt<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
			resize(x);
			<span style="color:#66d9ef">return</span>;
		}
		<span style="color:#66d9ef">if</span>(val<span style="color:#f92672">==</span>a[x].val) <span style="color:#f92672">++</span>a[x].cnt;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(val<span style="color:#f92672">&lt;</span>a[x].val) insert(ls(x),val);
		<span style="color:#66d9ef">else</span> insert(rs(x),val);
		pushup(x);
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delet</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x,<span style="color:#66d9ef">int</span> val){
		<span style="color:#66d9ef">if</span>(a[x].val<span style="color:#f92672">==</span>val) <span style="color:#f92672">--</span>a[x].cnt;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(val<span style="color:#f92672">&lt;</span>a[x].val) delet(ls(x),val);
		<span style="color:#66d9ef">else</span> delet(rs(x),val);
		pushup(x);
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rank</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x,<span style="color:#66d9ef">int</span> val){
		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>x) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">if</span>(val<span style="color:#f92672">==</span>a[x].val) <span style="color:#66d9ef">return</span> a[ls(x)].sm<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(val<span style="color:#f92672">&lt;</span>a[x].val) <span style="color:#66d9ef">return</span> rank(ls(x),val);
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> a[ls(x)].sm<span style="color:#f92672">+</span>a[x].cnt<span style="color:#f92672">+</span>rank(rs(x),val);
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kth</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x,<span style="color:#66d9ef">int</span> k){
		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>x) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&gt;</span>a[ls(x)].sm <span style="color:#f92672">&amp;&amp;</span> k<span style="color:#f92672">&lt;=</span>a[ls(x)].sm<span style="color:#f92672">+</span>a[x].cnt) <span style="color:#66d9ef">return</span> a[x].val;
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(k<span style="color:#f92672">&lt;=</span>a[ls(x)].sm) <span style="color:#66d9ef">return</span> kth(ls(x),k);
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> kth(rs(x),k<span style="color:#f92672">-</span>a[ls(x)].sm<span style="color:#f92672">-</span>a[x].cnt);
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pre</span>(<span style="color:#66d9ef">int</span> val){
		<span style="color:#66d9ef">return</span> kth(root,rank(root,val)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">suf</span>(<span style="color:#66d9ef">int</span> val){
		<span style="color:#66d9ef">return</span> kth(root,rank(root,val<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>));
	}
}shp;
</code></pre></div><h2 id="kd-tree">KD-Tree</h2>
<h3 id="建树">建树</h3>
<p>KD-Tree 是一个优雅的暴力，复杂度相对可观，但是比较裸的 KD-Tree 容易被卡常。来看一下这样一个题目：</p>
<blockquote>
<p>例题：在线地支持两个在平面直角坐标系上的操作：插入一个坐标为 $(x,y)$，点权为 $p$ 的点，查询一个矩形范围内的点权和。操作数 $2\times 10^5$，点权和坐标在 $\text{int}$ 范围内，时间限制 3s，空间限制 20MB。</p>
</blockquote>
<p>强制在线叉掉了 CDQ，20MB 的空间限制叉掉了树套树，真是毒瘤妈妈给毒瘤开门——毒瘤到家了。</p>
<p>因此我们就需要一个更加优秀的数据结构，可以很好地处理这个问题。KD-Tree 就是一个不错的选择。我们知道平衡树可以做到在一维（序列）的空间上对点进行很多高级的操作，KD-Tree 就是针对 K 维空间进行的。</p>
<p>为了简单画图和叙述，以二维空间为例子，看看这样子一个平面。</p>
<p><img src="https://pic.imgdb.cn/item/61a1f0872ab3f51d9119b75c.png" alt=""></p>
<p>如果是在一个一维序列上，我们就会遵循 BST 的性质，每次取当前区间的中位数作为根，然后递归地建树。这样建出来的树一定具有  SBT 性质，随后怎么在加点删点时维护平衡就是它自己的事情了。</p>
<p>如果能找到一个标准，使得平面上的点也能建在一个树上，然后尽可能地满足 SBT 性质，那么复杂度就是接近 $\log$ 级别的。</p>
<p>KD-Tree 并不把事情搞的很复杂，每次我们只需要选择一个维度，然后在当前区间内找到中位数位置划分即可。当然每次选择维度不宜都是同一个，不然非常容易退化，常见的方法是交替选维度。</p>
<p>例如先选择 $x$ 轴为根的选择标准，找到点 $\text{D}$。</p>
<p><img src="https://pic.imgdb.cn/item/61a1f2352ab3f51d911a78f7.png" alt=""></p>
<p>然后换一个维度，即 $y$ 轴维度，在得到的两个区间中各找到中位数点，注意到 $\text{B,G}$ 在同一线上，为了方便处理就随便选一个，另一个到时候再分。这里假设选择的是为 $\text{B,F}$，$\text{G}$ 和 $\text{A}$ 视为在同一区域，不和 $\text{C}$ 同一区域。</p>
<p><img src="https://pic.imgdb.cn/item/61a1f3002ab3f51d911ac6fa.png" alt=""></p>
<p>然后再按照 $x$ 轴分一下，再按照 $y$ 轴……以此类推，最后得到的图可能是这样：</p>
<p><img src="https://pic.imgdb.cn/item/61a1f5112ab3f51d911bb17e.png" alt=""></p>
<p>然后按照划分的顺序，假设对于 $x$ 轴，左边为左子树部分，右边为右子树部分；对于 $y$ 轴，上面为左子树部分，下面为右子树部分，就可以得到这样的一个树：</p>
<p><img src="https://pic.imgdb.cn/item/61a1f6782ab3f51d911c5094.png" alt=""></p>
<p>我们发现这个树看起来挺平衡的，那就可以根据这个关系来建树就行，控制了<strong>随机数据</strong>下在树上进行的操作复杂度约为 $\log$ 级别。</p>
<p>至于如何找到中位数，可以用 <code>nth_element</code> 函数，可以 $\operatorname{O}(n)$ 找到一个序列的中位数并把它放在目标位置。</p>
<h3 id="重构">重构</h3>
<p>这样就出现了一个问题，因为加点的时候一定是加在一个叶子上的，如果我一直往一个区域加一堆点，这个子树的根就不一定是原来的中位数了。然后加着加着这个树就不平衡了，复杂度就退化了。</p>
<p>只需要和替罪羊树一样，搞上一个平衡因子 $\alpha$，如果子树之间不平衡了就暴力拆下来重构即可。可以发现只要 $\alpha$ 定得好，复杂度还可以稳定在 $\log$ 级别。</p>
<p>然后到这里上面那个例题就可以做出来了，我们再维护一下一个点子树内的点权和，这个点本身的点权，和子数内所有点构成的最大矩形。询问的时候，如果询问矩形和这个点涵盖的矩形相离，不会造成贡献，如果询问区间包含了这个点涵盖的矩形，则直接返回这个点的子树点权和。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">bool</span> Begin;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> max_n<span style="color:#f92672">=</span><span style="color:#ae81ff">200055</span>;
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read</span>(){
	<span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#66d9ef">bool</span> w<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#66d9ef">char</span> c<span style="color:#f92672">=</span>getchar();
	<span style="color:#66d9ef">while</span>(c<span style="color:#f92672">&lt;</span><span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">||</span> c<span style="color:#f92672">&gt;</span><span style="color:#e6db74">&#39;9&#39;</span>) w<span style="color:#f92672">|=</span>c<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;-&#39;</span>,c<span style="color:#f92672">=</span>getchar();
	<span style="color:#66d9ef">while</span>(c<span style="color:#f92672">&gt;=</span><span style="color:#e6db74">&#39;0&#39;</span> <span style="color:#f92672">&amp;&amp;</span> c<span style="color:#f92672">&lt;=</span><span style="color:#e6db74">&#39;9&#39;</span>) x<span style="color:#f92672">=</span>(x<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span>(x<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">3</span>)<span style="color:#f92672">+</span>(c<span style="color:#f92672">^</span><span style="color:#ae81ff">48</span>),c<span style="color:#f92672">=</span>getchar();
	<span style="color:#66d9ef">return</span> w<span style="color:#f92672">?-</span>x:x;
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">int</span> x){
	<span style="color:#66d9ef">if</span>(x<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>) putchar(<span style="color:#e6db74">&#39;-&#39;</span>),x<span style="color:#f92672">=-</span>x;
	<span style="color:#66d9ef">if</span>(x<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">9</span>) write(x<span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>);
	putchar(x<span style="color:#f92672">%</span><span style="color:#ae81ff">10</span><span style="color:#f92672">^</span><span style="color:#ae81ff">48</span>);
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">interv</span>(<span style="color:#66d9ef">int</span> mid,<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r){ <span style="color:#75715e">// 判断 x 是否在区间 [l,r] 内
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>mid <span style="color:#f92672">&amp;&amp;</span> mid<span style="color:#f92672">&lt;=</span>r) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">max</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){<span style="color:#66d9ef">return</span> a<span style="color:#f92672">&gt;</span>b<span style="color:#f92672">?</span>a:b;}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">min</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){<span style="color:#66d9ef">return</span> a<span style="color:#f92672">&lt;</span>b<span style="color:#f92672">?</span>a:b;}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">point</span>{
	<span style="color:#66d9ef">int</span> x,y,val; <span style="color:#75715e">// 横纵坐标，权值
</span><span style="color:#75715e"></span>	point(){x<span style="color:#f92672">=</span>y<span style="color:#f92672">=</span>val<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;}
}pos[max_n];
<span style="color:#66d9ef">inline</span> point <span style="color:#a6e22e">makep</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b,<span style="color:#66d9ef">int</span> c){
	point res;
	res.x<span style="color:#f92672">=</span>a,res.y<span style="color:#f92672">=</span>b,res.val<span style="color:#f92672">=</span>c;
	<span style="color:#66d9ef">return</span> res;
}
<span style="color:#66d9ef">bool</span> cmpt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(point i,point j){ <span style="color:#75715e">// 根据 cmpt 决定是横坐标比较还是纵坐标比较
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(cmpt) <span style="color:#66d9ef">return</span> i.x<span style="color:#f92672">&lt;</span>j.x;
	<span style="color:#66d9ef">return</span> i.y<span style="color:#f92672">&lt;</span>j.y;
}

<span style="color:#66d9ef">int</span> fre[max_n],tp; <span style="color:#75715e">// 删除节点时腾出的空间，垃圾回收
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">KD_Tree</span>{
	<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.75</span>; <span style="color:#75715e">// 平衡因子
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> root,tot,tmp;
	<span style="color:#66d9ef">bool</span> chgr;
	KD_Tree(){root<span style="color:#f92672">=</span>tot<span style="color:#f92672">=</span>tmp<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">newnode</span>(){ <span style="color:#75715e">// 前面说的垃圾回收在这里用到了
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> x;
		<span style="color:#66d9ef">if</span>(tp) x<span style="color:#f92672">=</span>fre[tp<span style="color:#f92672">--</span>];
		<span style="color:#66d9ef">else</span> x<span style="color:#f92672">=++</span>tot;
		<span style="color:#66d9ef">return</span> x;
	}
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">dot</span>{
		point x,l,r;<span style="color:#75715e">// 这个点位置，涵盖的矩形的左上角和右下角
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> tp,sz,ls,rs,sm; <span style="color:#75715e">// 以哪个维度分，子树大小，左右儿子，子数点权和
</span><span style="color:#75715e"></span>		dot(){tp<span style="color:#f92672">=</span>sz<span style="color:#f92672">=</span>ls<span style="color:#f92672">=</span>rs<span style="color:#f92672">=</span>sm<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;}
	}a[max_n];
	<span style="color:#75715e">#define ls(x) (a[x].ls)
</span><span style="color:#75715e"></span>	<span style="color:#75715e">#define rs(x) (a[x].rs)
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pushup</span>(<span style="color:#66d9ef">int</span> x){
		a[x].l<span style="color:#f92672">=</span>a[x].r<span style="color:#f92672">=</span>a[x].x,a[x].sm<span style="color:#f92672">=</span>a[x].x.val; <span style="color:#75715e">// 初始化信息
</span><span style="color:#75715e"></span>		a[x].sz<span style="color:#f92672">=</span>a[ls(x)].sz<span style="color:#f92672">+</span>a[rs(x)].sz<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 更新子树大小
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(ls(x)){ <span style="color:#75715e">// 维护子树点权和以及涵盖矩形
</span><span style="color:#75715e"></span>			a[x].sm<span style="color:#f92672">+=</span>a[ls(x)].sm;
			a[x].l.x<span style="color:#f92672">=</span>min(a[x].l.x,a[ls(x)].l.x),a[x].r.x<span style="color:#f92672">=</span>max(a[x].r.x,a[ls(x)].r.x);
			a[x].l.y<span style="color:#f92672">=</span>min(a[x].l.y,a[ls(x)].l.y),a[x].r.y<span style="color:#f92672">=</span>max(a[x].r.y,a[ls(x)].r.y);
		}
		<span style="color:#66d9ef">if</span>(rs(x)){
			a[x].sm<span style="color:#f92672">+=</span>a[rs(x)].sm;
			a[x].l.x<span style="color:#f92672">=</span>min(a[x].l.x,a[rs(x)].l.x),a[x].r.x<span style="color:#f92672">=</span>max(a[x].r.x,a[rs(x)].r.x);
			a[x].l.y<span style="color:#f92672">=</span>min(a[x].l.y,a[rs(x)].l.y),a[x].r.y<span style="color:#f92672">=</span>max(a[x].r.y,a[rs(x)].r.y);
		}
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r,<span style="color:#66d9ef">int</span> t){ <span style="color:#75715e">// 建树，t 为当前划分维度
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span>newnode(),mid<span style="color:#f92672">=</span>(l<span style="color:#f92672">+</span>r)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>;
		cmpt<span style="color:#f92672">=</span>t;
		nth_element(pos<span style="color:#f92672">+</span>l,pos<span style="color:#f92672">+</span>mid,pos<span style="color:#f92672">+</span>r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,cmp);
		a[x].tp<span style="color:#f92672">=</span>t,a[x].x<span style="color:#f92672">=</span>pos[mid],ls(x)<span style="color:#f92672">=</span>rs(x)<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&lt;=</span>mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) ls(x)<span style="color:#f92672">=</span>build(l,mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,t<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 交替划分
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(r<span style="color:#f92672">&gt;=</span>mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) rs(x)<span style="color:#f92672">=</span>build(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,r,t<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>);
		pushup(x);
		<span style="color:#66d9ef">return</span> x;
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">int</span> x){ <span style="color:#75715e">// 和替罪羊一样，先拍扁
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(ls(x)) get(ls(x));
		pos[<span style="color:#f92672">++</span>tmp]<span style="color:#f92672">=</span>a[x].x,
		fre[<span style="color:#f92672">++</span>tp]<span style="color:#f92672">=</span>x;
		<span style="color:#66d9ef">if</span>(x<span style="color:#f92672">==</span>root) chgr<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">if</span>(rs(x)) get(rs(x));
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rebuild</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x){ <span style="color:#75715e">// 重新构造这个子树
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(alpha<span style="color:#f92672">*</span>a[x].sz<span style="color:#f92672">&gt;</span>max(a[ls(x)].sz,a[rs(x)].sz)) <span style="color:#66d9ef">return</span>; <span style="color:#75715e">// 不需要重构
</span><span style="color:#75715e"></span>		tmp<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,chgr<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
		get(x);
		x<span style="color:#f92672">=</span>build(<span style="color:#ae81ff">1</span>,tmp,<span style="color:#ae81ff">0</span>);
		<span style="color:#66d9ef">if</span>(chgr) root<span style="color:#f92672">=</span>x;
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x,point pt,<span style="color:#66d9ef">int</span> t){ <span style="color:#75715e">// 添加一个点，用 t 这个方法划分维度
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>x){
			x<span style="color:#f92672">=</span>newnode();
			a[x].sz<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,a[x].x<span style="color:#f92672">=</span>pt,a[x].tp<span style="color:#f92672">=</span>t;
			pushup(x);
			<span style="color:#66d9ef">return</span>;
		}
		cmpt<span style="color:#f92672">=</span>t;
		<span style="color:#66d9ef">if</span>(cmp(pt,a[x].x)) insert(ls(x),pt,t<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 交替划分
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">else</span> insert(rs(x),pt,t<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span>);
		pushup(x),rebuild(x);
	}
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ask</span>(<span style="color:#66d9ef">int</span> x,point i,point j){ <span style="color:#75715e">// 询问区间和
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>x <span style="color:#f92672">||</span> a[x].l.x<span style="color:#f92672">&gt;</span>j.x <span style="color:#f92672">||</span> a[x].r.x<span style="color:#f92672">&lt;</span>i.x <span style="color:#f92672">||</span> a[x].l.y<span style="color:#f92672">&gt;</span>j.y <span style="color:#f92672">||</span> a[x].r.y<span style="color:#f92672">&lt;</span>i.y) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 不存在该点或者与询问矩形相离
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(a[x].l.x<span style="color:#f92672">&gt;=</span>i.x <span style="color:#f92672">&amp;&amp;</span> a[x].r.x<span style="color:#f92672">&lt;=</span>j.x <span style="color:#f92672">&amp;&amp;</span> a[x].l.y<span style="color:#f92672">&gt;=</span>i.y <span style="color:#f92672">&amp;&amp;</span> a[x].r.y<span style="color:#f92672">&lt;=</span>j.y) <span style="color:#75715e">// 能涵盖到的矩形被询问矩形涵盖
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> a[x].sm;
		<span style="color:#66d9ef">int</span> res<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
		<span style="color:#66d9ef">if</span>(interv(a[x].x.x,i.x,j.x) <span style="color:#f92672">&amp;&amp;</span> interv(a[x].x.y,i.y,j.y)) res<span style="color:#f92672">+=</span>a[x].x.val; <span style="color:#75715e">// 该点本身在询问矩形内
</span><span style="color:#75715e"></span>		res<span style="color:#f92672">+=</span>ask(ls(x),i,j)<span style="color:#f92672">+</span>ask(rs(x),i,j);
		<span style="color:#66d9ef">return</span> res;
	}
}kdt;

<span style="color:#66d9ef">bool</span> ndp<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,End; <span style="color:#75715e">// ndp 表示是否强制在线
</span><span style="color:#75715e"></span><span style="color:#66d9ef">signed</span> <span style="color:#a6e22e">main</span>(){
	<span style="color:#75715e">//cerr&lt;&lt;&#34;Memory: &#34;&lt;&lt;1.0*(&amp;Begin-&amp;End)/1024/1024&lt;&lt;&#34;MB\n&#34;&lt;&lt;&#34;\n&#34;;
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> lst<span style="color:#f92672">=</span>read();lst<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
		<span style="color:#66d9ef">int</span> op<span style="color:#f92672">=</span>read();
		<span style="color:#66d9ef">if</span>(op<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>){
			<span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span>read(),y<span style="color:#f92672">=</span>read(),z<span style="color:#f92672">=</span>read();
			<span style="color:#66d9ef">if</span>(ndp) x<span style="color:#f92672">^=</span>lst,y<span style="color:#f92672">^=</span>lst,z<span style="color:#f92672">^=</span>lst;
			kdt.insert(kdt.root,makep(x,y,z),<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 插入一个点
</span><span style="color:#75715e"></span>		}
		<span style="color:#66d9ef">if</span>(op<span style="color:#f92672">==</span><span style="color:#ae81ff">2</span>){
			<span style="color:#66d9ef">int</span> x<span style="color:#f92672">=</span>read(),y<span style="color:#f92672">=</span>read(),a<span style="color:#f92672">=</span>read(),b<span style="color:#f92672">=</span>read();
			<span style="color:#66d9ef">if</span>(ndp) x<span style="color:#f92672">^=</span>lst,y<span style="color:#f92672">^=</span>lst,a<span style="color:#f92672">^=</span>lst,b<span style="color:#f92672">^=</span>lst;
			write(lst<span style="color:#f92672">=</span>kdt.ask(kdt.root,makep(x,y,<span style="color:#ae81ff">0</span>),makep(a,b,<span style="color:#ae81ff">0</span>))),putchar(<span style="color:#e6db74">&#39;\n&#39;</span>); <span style="color:#75715e">// 矩形范围用两个点来表示
</span><span style="color:#75715e"></span>		}
		<span style="color:#66d9ef">if</span>(op<span style="color:#f92672">==</span><span style="color:#ae81ff">3</span>)
			<span style="color:#66d9ef">break</span>;
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><a href="https://hydro.ac/d/bzoj/record/61a1bd42f8317b1215f1f12c">实测</a>最慢的点不超过 2s。事实上，交替选点的复杂度一般视为单次树上操作 $\sqrt{n}$ 级别的。</p>
<h3 id="估价">估价</h3>
<p>假设把求矩形内点权和，改成查询离一个点的曼哈顿距离最近的点的距离。</p>
<p>我们发现上面的划分方法有一个很大的弊端，就是有可能一个点和另一个点很近，但是在树上并不出在相邻的位置。举个例子，上面那个图（如果懒得翻，这里也放一个）：</p>
<p><img src="https://pic.imgdb.cn/item/61a1f5112ab3f51d911bb17e.png" alt=""></p>
<p>和 $\text{E}$ 最近的点是 $\text{F}$，但是显然 $\text{F}$ 和 $\text{E}$ 不成相邻关系。如果右边这一部分画得分散一点，搞不好离 $\text{E}$ 最近的是 $\text{G}$，那就连祖先关系都不是。</p>
<p>因此每次询问的时候，就只能暴力跑一遍整个树吗？那我还建这个树干嘛。因此需要考虑怎么进行优化。</p>
<p>如果当前我找到的这个点，它的能涵盖到的矩形，距离询问点的距离还大于等于当前找到的最优答案，那还要往这个点的子树找干什么。</p>
<p>这样的看起来显然的优化实际上可以让复杂度变得非常优秀。确定好一个合适的搜索顺序后，基本可以看为也是根号级别的。这就是 KD-Tree 的估价。</p>
<p>这里给出一个例子。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> i){ <span style="color:#75715e">// 估价函数
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>x) <span style="color:#66d9ef">return</span> inf; <span style="color:#75715e">// 不存在这个点，显然不能往这里搜
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> max(a[x].l.x<span style="color:#f92672">-</span>d[i].x,<span style="color:#ae81ff">0</span>)<span style="color:#f92672">+</span>max(d[i].x<span style="color:#f92672">-</span>a[x].r.x,<span style="color:#ae81ff">0</span>)<span style="color:#f92672">+</span>max(a[x].l.y<span style="color:#f92672">-</span>d[i].y,<span style="color:#ae81ff">0</span>)<span style="color:#f92672">+</span>max(d[i].y<span style="color:#f92672">-</span>a[x].r.y,<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 点到矩形曼哈顿距离最小值
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> id){
	<span style="color:#66d9ef">if</span>(a[x].id<span style="color:#f92672">!=</span>id) <span style="color:#75715e">// 查寻点和我现在的点不同，更新答案
</span><span style="color:#75715e"></span>		ans<span style="color:#f92672">=</span>min(ans,abs(a[x].x.x<span style="color:#f92672">-</span>d[id].x)<span style="color:#f92672">+</span>abs(a[x].x.y<span style="color:#f92672">-</span>d[id].y));
	<span style="color:#66d9ef">int</span> al<span style="color:#f92672">=</span>check(ls(x),id),ar<span style="color:#f92672">=</span>check(rs(x),id); <span style="color:#75715e">// 计算左右子树估价
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>(al<span style="color:#f92672">&lt;</span>ar){ <span style="color:#75715e">// 哪个子树更近，先走哪个，使得较优的答案更早算出来，减枝更多
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(al<span style="color:#f92672">&lt;</span>ans) query(ls(x),id); <span style="color:#75715e">// 如果到矩形的距离都比当前的最有答案大，别走
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>(ar<span style="color:#f92672">&lt;</span>ans) query(rs(x),id);
	}
	<span style="color:#66d9ef">else</span>{
		<span style="color:#66d9ef">if</span>(ar<span style="color:#f92672">&lt;</span>ans) query(rs(x),id);
		<span style="color:#66d9ef">if</span>(al<span style="color:#f92672">&lt;</span>ans) query(ls(x),id);
	}
}
</code></pre></div><h2 id="例题">例题</h2>
<h4 id="bzoj2683-简单题">BZOJ2683 简单题</h4>
<p><a href="https://hydro.ac/d/bzoj/p/2683">题目连接</a>，就是上面引入 KD-Tree 的例题。</p>
<h3 id="luogu4169-天使玩偶">luogu4169 天使玩偶</h3>
<p><a href="https://www.luogu.com.cn/problem/P4169">题目连接</a>，就是改成求曼哈顿距离最近的这个题。</p>
<h3 id="bzoj3489-a-simple-rmq-problem">BZOJ3489 A simple rmq problem</h3>
<p><a href="https://hydro.ac/d/bzoj/p/3489">题目连接</a>，大概题意如下：</p>
<p>对于一个给定的序列，要求强制在线地处理若干询问，每次询问给定 $l,r$ 求 $[l,r]$ 内最大的一个数字，满足这个数字在区间中只出现了一次。</p>
<p>$n,m,a_i\leqslant 2\times 10^5$。</p>
<!-- raw HTML omitted -->
<h3 id="bzoj4154-generating-synergy">BZOJ4154 Generating Synergy</h3>
<p><a href="https://hydro.ac/d/bzoj/p/4154">题目连接</a>，大概题意如下：</p>
<p>对于一个有根带点权树，支持两个操作：一是修改 $x$ 子树与 $x$ 距离不超过 $k$ 的点的点权，二是查询一个点的点权。</p>
<p>$n,m\leqslant 10^5$。</p>
<!-- raw HTML omitted -->

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>Permalink: </strong>
      <a href="https://walker68145/Arahc.github.io/posts/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E4%B8%8Ekdtree/" title="替罪羊与KDTree" target="_blank" rel="external">https://walker68145/Arahc.github.io/posts/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E4%B8%8Ekdtree/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License: </strong>
        <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external"></a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Walker_68145" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://walker68145/Arahc.github.io/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Walker_68145" target="_blank"><span class="text-dark">Arahc</span><small class="ml-1x">Arahc&#39;s home</small></a></h3>
        <div>咕↘咕↗咕——→</div>
      </div>
    </figure>
  </div>
</div>

    </div>
  </article>
</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://walker68145/Arahc.github.io/posts/p3830%E9%9A%8F%E6%9C%BA%E6%A0%91-%E9%A2%98%E8%A7%A3/" title="P3830随机树 题解"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;Older</span></a>
            </li>
            <li class="next">
                <a href="https://walker68145/Arahc.github.io/posts/oi-%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E5%88%87%E9%A2%98%E5%86%85%E5%AE%B9/"
                    title="OI 相关的非切题内容"><span>Newer&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="Catalogue" role="button">
                    <span>[&nbsp;</span><span>Catalogue</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


</main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/Walker_68145" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://walker68145/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2017  -
    2021
    <div class="publishby">
        Theme by <a href="https://github.com/xiaoheiAh" target="_blank"> xiaoheiAh </a>base on<a href="https://github.com/xiaoheiAh/hugo-theme-pure" target="_blank"> pure</a>.
    </div>
    
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/C&#43;&#43;.min.js" defer></script><script>
    hljs.configure({
        tabReplace: '    ', 
        classPrefix: ''     
        
    })
    hljs.initHighlightingOnLoad();
</script>
<script src="https://walker68145/Arahc.github.io/js/application.min.a94ab19cb63a95c8d7fbd7b85cab3ddeea8c369bdf75b9cab6708787ead123af.js"></script>
<script src="https://walker68145/Arahc.github.io/js/plugin.min.19c5bcb2fb0789ab4f2b7834e5ceb5e92635645605bab902c1024b25f1502364.js"></script>

<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            ROOT_URL: 'https:\/\/walker68145\/Arahc.github.io',
            CONTENT_URL: 'https:\/\/walker68145\/Arahc.github.io\/searchindex.json ',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script type="text/javascript" src="https://walker68145/Arahc.github.io/js/insight.min.4a2d52de4bfff73e0c688404fe3d17c9a3ae12d9888e1e1ac9c690e4890de2ded50fe55f2b819c2ba55435a76f396f3ea6805765f0b0af5635cdf74ea459eab0.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    tocbot.init({
        
        tocSelector: '.js-toc',
        
        contentSelector: '.js-toc-content',
        
        headingSelector: 'h1, h2, h3',
        
        hasInnerContainers: true,
    });
</script>


  </body>
</html>
