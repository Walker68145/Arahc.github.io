<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>k进制 on Arahc&#39;s blog</title>
    <link>http://walker68145.github.io/Arahc.github.io/tags/k%E8%BF%9B%E5%88%B6/</link>
    <description>Recent content in k进制 on Arahc&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 Aug 2021 21:46:14 +0800</lastBuildDate>
    
        <atom:link href="http://walker68145.github.io/Arahc.github.io/tags/k%E8%BF%9B%E5%88%B6/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>概率与期望</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</link>
      <pubDate>Wed, 28 Jul 2021 20:38:26 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/</guid>
      <description>前言 从前有一个屑到要被淘汰的菜 Oier（其实就是我），他写了一个博客叫“浅谈数学期望”。然后好巧不巧在某一次更新博客的时候以前的文章全部被覆盖了，因为没有存笔记所以直接全部消失。这个人想着算了，覆盖掉就覆盖掉吧，鬼才会写概率和期望的博客。
半年后的今天，这个死鬼居然补起了学习笔记，好巧不巧，正好就有概率和期望。（我：WDNMD）
所以今天来写一波概率和期望的笔记。学长讲的时候都是以例题为主，顺带就把在洛谷上平均难度都是冷色系的概率 DP 一起水过去了，差点让我没跟上。所以这一次仔细写一写。
概率 概率，都不陌生，凡是有初中数学基础（好像是小学？）的都不会不知道什么是概率。
 概率，亦称“或然率”，它是反映随机事件出现的可能性大小。随机事件是指在相同条件下，可能出现也可能不出现的事件。例如，从一批有正品和次品的商品中，随意抽取一件，“抽得的是正品”就是一个随机事件。设对某一随机现象进行了 $n$ 次试验与观察，其中 $A$ 事件出现了 $m$ 次，即其出现的频率为 $\frac{m}{n}$。经过大量反复试验，常有 $\frac{m}{n}$ 越来越接近于某个确定的常数（此论断证明详见伯努利大数定律）。该常数即为事件 $A$ 出现的概率，常用 $\operatorname{P}(A)$ 表示。（摘自百度）
 举几个简单的例子，投一个骰子，$6$ 朝上的概率是 $\frac{1}{6}$，朝上的数字是奇数的概率是 $\frac{1}{2}$，是自然数的概率是 $1$，是负数的概率是 $0$。
至于穷举法树状图法表格法频率法计算法求概率，这篇文章不是数学课讲义，显然没必要赘述。
期望 期望好像不是初中的东西，简单提一下（其实是重点啊喂）
 在概率论和统计学中，数学期望（mean）（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。 需要注意的是，期望值并不一定等同于常识中的“期望”——“期望值”也许与每一个结果都不相等。期望值是该变量输出值的平均数。期望值并不一定包含于变量的输出值集合里。（摘自百度）
 期望就是这件事所有的结果（用一个数值表示）乘上它对应的概率，然后全部加起来。说的有点玄乎，举个例子看看：抛一个骰子，朝上的一面的数字期望是多少？
显然数字可能是 $1,2,3,4,5,6$，对应的概率都是 $\frac{1}{6}$，因此朝上的一面期望值是：
$$1\times\dfrac{1}{6}+2\times\dfrac{1}{6}+3\times\dfrac{1}{6}+4\times\dfrac{1}{6}+5\times\dfrac{1}{6}+6\times\dfrac{1}{6}=3.5$$
  引导例题：同时投两个骰子，朝上的一面数的和的期望。
 每个骰子的数字都是 $1,2,3,4,5,6$，所以总和是 $[2,12]$，但是这些和出现的概率是均等的吗？但凡做过小学题都知道不均等。最原始的方法还是莫过于初中数学的表格法暴力枚举： （为什么不用树状图法？只要你画得比这 $\LaTeX$ 做的表格还好看我就换）
   \ 1 2 3 4 5 6     1 2 3 4 5 6 7   2 3 4 5 6 7 8   3 4 5 6 7 8 9   4 5 6 7 8 9 10   5 6 7 8 9 10 11   6 7 8 9 10 11 12    一共有 $36$ 种情况，其中出现 $7$ 的次数最多。这能否代表 $7$ 一定是期望值呢？显然不能，例如一个骰子的时候，作为期望值的 $3.</description>
    </item>
    
    <item>
      <title>模意义下的数学</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Mon, 19 Jul 2021 14:41:28 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%A6/</guid>
      <description>填完了线性代数和积性函数和莫比乌斯反演的坑之后，来补一下取模的笔记。
前置导入 什么是取模？  取模运算是求两个数相除的余数。 取模运算（“Modulo Operation”）和取余运算（“Remainder Operation ”）两个概念有重叠的部分但又不完全一致。主要的区别在于对负整数进行除法运算时操作不同。取模主要是用于计算机术语中。取余则更多是数学概念。 模运算在数论和程序设计中都有着广泛的应用，奇偶数的判别到素数的判别，从模幂运算到最大公约数的求法，从孙子问题到凯撒密码问题，无不充斥着模运算的身影。虽然很多数论教材上对模运算都有一定的介绍，但多数都是以纯理论为主，对于模运算在程序设计中的应用涉及不多。 （摘自百度）
 前置知识 $\bmod$ 表示取模运算，也就是两数相除取其余数，在 C++ 中用 % 表示。$a\bmod{b}$ 表示求 $a$ 除以 $b$ 的余数。下面这个式子 $a\equiv b\pmod{p}$ 可以理解为 $a\bmod{p}=b\bmod{p}$。模运算与乘除运算同等级。但是本文有些地方为了方便就将模运算提升到比乘除高一个优先级的地方去了。
$\operatorname{A}_n^m$ 表示从 $n$ 个不同的元素中任意取出其中 $m$ 个元素的所有排列数的个数。其中一定有 $m\leqslant n$，若 $m&amp;gt;n$，则 $\operatorname{A}_n^m=0$。
$\operatorname{C}_n^m$ 表示从 $n$ 个不同的元素中任意取出其中 $m$ 个元素且并称一个组合（不区分顺序）的方案数。其中一定有 $m\leqslant n$，若 $m&amp;gt;n$，则 $\operatorname{A}_n^m=0$。
充分条件：对于某一个命题，若条件成立的时候命题一定正确（命题正确的时候条件成立与否不管），则称这个条件是这个命题的充要条件。
必要条件：对于某一个命题，若命题成立的时候条件一定成立（条件成立的时候命题成立与否不管），则称这个条件是这个命题的必要条件。
充分必要条件：字面意思。
其他的出现的初中没有的符号都在前两期数学有关的博客中：线性代数，积性函数和莫比乌斯反演。
关于本文  如果有误，洛谷私信。 本文不带有任何网上找的例题，如果有需要自行查找。 没有提到的变量范围请根据上下文情景判断，一般为有理数范围或正整数范围。 本文仅为信息学竞赛基本需要掌握的内容，不代表其学科的全部。 大部分内容源自校内讲课和网络资源。 因为这里模块较多且涵盖许多有关模运算的算法，对模运算本身没有过多介绍。  模意义与逆元 模意义及其性质 小学的时候我们都做过整数除法，例如 $27\div 4 = 6 \cdots 3$。这里的 $27$ 是被除数，$4$ 是除数，$6$ 是商，$3$ 是余数（都是老生常谈了吧）。模运算的表示为 $27 \equiv 3 \pmod{4}$。表示 $27$ 和 $3$ 在模 $4$ 意义下是相等的。因为 $27$ 和 $3$ 显然本来不相等，但这两个数除以 $4$ 的余数相同，就可以称 $27$ 和 $3$ 在模 $4$ 意义下是相等的。</description>
    </item>
    
    <item>
      <title>浅谈线性代数</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</link>
      <pubDate>Sun, 18 Jul 2021 12:45:09 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</guid>
      <description>学了线性代数的一些内容。简单做一个笔记。
前置内容 什么是线性代数？  线性代数是数学的一个分支，它的研究对象是向量，向量空间（或称线性空间），线性变换和有限维的线性方程组。向量空间是现代数学的一个重要课题。 线性代数的理论已被泛化为算子理论。由于科学研究中的非线性模型通常可以被近似为线性模型，使得线性代数被广泛地应用于自然科学和社会科学中，因而在各种代数分支中占居首要地位。（摘自百度）
 学完线性代数，就有了对空间抽象成代数的思想。但是不一定有这个能力
前置数学知识 向量：$\vec{c}$，在计算机领域表示一个一维数组，在几何领域，表示一个有方向的线段。
矩阵：形如 $\begin{bmatrix} a &amp;amp; b \ c &amp;amp; d \end{bmatrix}$ 之类的东西，记高为 $n$，宽为 $m$，则这是一个 $n\times m$ 的矩阵，写出下标时先行后列，如 $b$ 的下标为 $(1,2)$。
笛卡尔坐标系：平面直角坐标系和斜坐标系的统称。平面直角坐标系不必多说，斜坐标系就是平面直角坐标系中 $x,y$ 轴不一定互相垂直。
其他有关线性代数的符号会在后文提到。如果出现了这里没提到的符号，可以转步我的另一篇文章，里面会提到一些，如果一些符号在那里出现过，这里不会过多赘述。
关于本文  如果有误，洛谷私信。 本文不带有任何网上找的例题，如果有需要自行查找。 没有提到的变量范围请根据上下文情景判断，一般为有理数范围或正整数范围。 线性代数是一门深奥的学科，本文仅为信息学竞赛需要的内容。 大部分内容源自校内讲课和视频讲解。  向量 向量的表示和定义 向量有着多重含义。在计算机上，向量可以视为一个一维数组，在数学上，则是坐标系上一个带有方向的线段，在物理里，它是一个有方向和大小的标量（物理里一般称“矢量”）
向量可以视为一个有向的线段，如果对于一个线段 $AB$，记它的方向为从端点 $A$ 到端点 $B$，则线段就具有了它的方向和长度。向量的长度就是有向线段的长度，向量 $\vec{a}$ 的长度记为 $\left\vert \vec{a} \right\vert$。向量的长度也称作向量的模。
因为长度之间是有长短关系的，所以向量的模具备大小关系。但是注意向量本身不具备大小关系，因为方向是不能比较大小的。对向量之间进行“大于”或“小于”等比较没有意义。
长度为一个单位长度的向量称为单位向量，若存在一个向量 $\vec{x}$ 与向量 $\vec{a}$ 方向相同（同向），且 $\left\vert \vec{x} \right\vert=1$，则称 $\vec{x}$ 是 $\vec{a}$ 方向上的单位向量。
如果两个向量的模相同，但是方向相反，称为两个向量互为负向量。也可以成为互为相反向量；如果两个向量的模相同，方向也相同，则它们为相等向量，例如一对相等向量 $\vec{a}$ 和 $\vec{b}$，可以记为 $\vec{a}=\vec{b}$。</description>
    </item>
    
    <item>
      <title>浅谈数论</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E6%B5%85%E8%B0%88%E6%95%B0%E8%AE%BA/</link>
      <pubDate>Sat, 17 Jul 2021 21:44:45 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E6%B5%85%E8%B0%88%E6%95%B0%E8%AE%BA/</guid>
      <description>今天学长给我们教了数论选讲，把里面的精髓提出来浅谈记录一下。顺便附上机房一位神仙对本文的注解
什么是数论？ 摘自 百度：
 数论是纯粹数学的分支之一，主要研究整数的性质。整数可以是方程式的解。有些解析函数中包括了一些整数、质数的性质，透过这些函数也可以了解一些数论的问题。
 数论被高斯成为“数学皇后”，是一大必不可少的分支。
前置导入 积性函数 积性函数代指一类函数。若函数 $\operatorname{f}$ 满足对于两个互质的数 $a,b$，$\operatorname{f}(a)\times \operatorname{f}(b)=\operatorname{f}(ab)$，则 $\operatorname{f}$ 为积性函数。
简单而言，对于一个函数 $\operatorname{f}(n)$，若 $\forall a,b\in \natnums^{+} \And \gcd(a,b)=1, \operatorname{f}(a)\times \operatorname{f}(b) = \operatorname{f}(ab)$，那么 $\operatorname{f}$ 是一个积性函数。
常见的积性函数有 $\varphi, \mu,\operatorname{id}$ 等等，下面将会提到一部分。
部分数学符号选讲 有高中数学基础的可以直接跳过。
$\prod$ 表示连乘，举例为：$\prod_{i=1}^N x_i$ ，意思是 $x_1\times x_2\times x_3\times \cdots \times x_N$。
$\sum$ 表示累加，举例为：$\sum_{i=1}^N x_i$ ，意思是 $x_1 + x_2 + x_3 + \cdots x_N$。
$\forall$ 表示“所有的”，$\exist$ 表示“存在”，$\And$ 表示“且”。
$\in$ 表示属于，$a\in A$ 表示元素 $a$ 属于集合 $A$。$\natnums^{+}$ 表示正整数集合，$\natnums$ 表示自然数集合（非负整数集合）。</description>
    </item>
    
    <item>
      <title>Shape 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/shape-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Mon, 12 Jul 2021 13:46:35 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/shape-%E9%A2%98%E8%A7%A3/</guid>
      <description>题意简述 给定一个 $n\times m$ 的 $0-1$ 矩阵，定义一个 H 形为一个长得像 H （感性理解，具体见题目描述）的图形，求有几个由 $0$ 组成的 H 形。
例如下图图示（白色为 $0$，黑色为 $1$），一共有 $6$ 个 H 形，这也告诉我们 H 形是可以互相有重叠甚至有包含关系的（但不同的 H 形不会完全恰好重合）。
题目分析 考虑到 $n,m\leqslant 2\times 10^3$。需要设计一个 $n\times m$ （或带一个 log ）的算法，直接暴力枚举四元组中的任意两个都无法完成，需要找到 H 形中的一个特性。
首先考虑是否可以枚举 H 的竖线（每个 H 有两个竖线，这里考虑左侧）。考场上糊了一个想法：记录每一条竖着的白线，以及每一个点往右可以到达的最近的点，图示情况可以后续推乘法原理加法原理的式子做到 $\operatorname{O}{(1)}$。随后很快发现了不可行，因为即使我记录了每一个点向右最多可以到达哪些点，整体判断一个 H 的两条竖线是否一一对应还是 $\operatorname{O}{(n)}$ 的。
除此之外，即使两个 $H$ 竖线部分是包含关系，也不一定代表横线部分重合，例如：
这两种情况都无法简单地区分，例如前面这种，高度为 $3$ 的 H 和高度为 $9$ 的 H 竖线部分共线但是横线部分不共线。后面这种情况说明不能只记录每一个白格子右侧第一个白格子，因为两个 H 可能只有一个竖线共线。
因此考虑竖线的情况比较难处理，又因为 H 里面只有一条横线，来考虑横线的情况。
对于任何一个 H，显然横线的两端刚好是竖线的中点。因此选择一个横线的两个端点，向上和向下延伸同样的高度（且都是白格子），就一定可以得出一个 H。
基于这种思想我们记录每一个格子向上最多可以延伸多少个格子，向下最多可以延伸多少个格子。
而显然一个横线两端的点向上和向下延伸的白格子应该是相同的，因此对于某一个格子而言，向上延伸和向下延伸的格子数取最小值，才会是以它为横线的一个端点，可能形成的高度最大的 H 的高度的一半。</description>
    </item>
    
    <item>
      <title>从BST到Splay</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E4%BB%8Ebst%E5%88%B0splay/</link>
      <pubDate>Sun, 11 Jul 2021 21:36:09 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E4%BB%8Ebst%E5%88%B0splay/</guid>
      <description>从堆到二叉搜索树 引言 考虑你需要维护一个数据结构，需要进行以下若干操作：
 添加一个值 value 删除一个值 value 查询值 value 的排名 查询排名为 rank 的值 求值 value 的前驱和后继  显然，如果只需要进行添加操作、查询最大值（最小值），只需要用一个二查堆，就可以解决。如果外加删除操作，则可以开启懒惰标记进行删除。整体复杂度是 $\operatorname{O}{(\log n)}$ 的。
堆的特性是根的节点的值比左右子树的都要大，于是我们扩展了一下，就可以变成二叉搜索树：对于某个节点 $i$ ，他的值 $data_i$ 大于左儿子节点的值，小于右儿子节点的值。
二叉搜索树 维护这样一个二叉搜索树，如下图：
$\color{red}\text{添加：}$
考虑我们需要添加一个数，比如 $25$。
首先我们应该找到 $25$ 应该放在哪里，所以从根节点出发，遵循二叉搜索树左儿子小于根节点（右儿子大于根节点）的原则，因为要添加的数字 $&amp;lt;41$ 所以来到左边，同理因为 $25&amp;gt;20$ 所以跳到 $20$ 右儿子，又因为 $25&amp;lt;29$，我们得出 $25$ 在 $29$ 左子树上。
因为 $29$ 没有左儿子，所以可以在这里新建一个节点。也就是添加完变成了这样（用颜色高亮标记了走过的点）：
当然如果我插入一个已经存在的树，可以记录每个数出现的次数，更为方便。
可以得出添加操作的伪代码如下：
void add(int x){ int u = root ; while true : if 找到要填的地方 : 添加节点（新建节点，更新 u 和新节点关系等）; return ; if x&amp;lt; 当前这个点的值 u = u 的左儿子 else : u = u 的右儿子 } $\color{Goldenrod}\text{删除：}$</description>
    </item>
    
    <item>
      <title>管道迷宫 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E7%AE%A1%E9%81%93%E8%BF%B7%E5%AE%AB-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Sat, 03 Jul 2021 21:38:55 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E7%AE%A1%E9%81%93%E8%BF%B7%E5%AE%AB-%E9%A2%98%E8%A7%A3/</guid>
      <description>题目传送门
（团队题库，不可见，重题见 此处 ）
题外话 本来是去年一个有关树然后有个线上下扫的交互题今年把它实现出来。
结果后来还是算了，搞了一个物理学的东西，是准备用来当考试题的。
鬼晓得这玩意没一个人知道比暴力优的解法，我自己都不知道。
然后想到去年还有个想法，稍微改了一下，发现和网上某题重了。
实在懒得出新题目了重就重吧没人做过就行。
题目分析 题目长度适中偏长，符合 NOIP 题面长度套路，但是是真交互题，CCF 没考过。
简单来说，就是给一个以 $1$ 为根的有根树，然后有两种交互，一种查询两点距离，一种查询一个点的子树。要求用父亲表示法把树还原出来。
你看吧虽然题面很长但简化出来只有一句话，所以还是不符合 CCF 的出题习惯。
测试数据 1 不难看出这个数据就是一个菊花图。
注意了，这个菊花图的花蕊不一定是根节点，事实上数据也不是。只要你够细心就知道还有一种情况是花蕊的海拔是 $-1$，换句话说树高为 $3$。
就算你不知道这个花蕊是不是根节点，分类讨论总会吧。
一个简单的做法，枚举每个点和根节点的距离。如果除了根节点，所有点距离都是 $1$，说明是 $1$ 为花蕊的菊花，否则一定只有一个点距离为 $1$，别的都是 $2$。那个距离为 $1$ 的就是花蕊。
我才不会告诉你这个数据差点卡掉了 100 分的正解。
测试数据 2~5 （ 25 分暴力算法） 我摊牌了表格里我写的小于等于其实所有数据 n 都开到等于了。
所以没有必要讨论玄学骗分算法。
考虑到可询问次数大于 $n^2$，最简单的算法就是暴力枚举两个点，查询一下距离。如果距离是 $1$ 就说明是有边直接连接的。
因此暴力查询距离得到联通关系，相当于是知道这个树的边了，显然再跑一遍 dfs 就可以得出父子关系。
测试数据 6~8 不难得出这两个数据点都是说这个树是一条链。
链是个好东西，为什么？因为一个点只会有一个儿子啊。
询问次数卡到了大约是 $2n$ 的水平，可以考虑在上一组测试数据的基础上优化。
因为每一个深度都只有一个点，我们可以暴力询问每一个点和根节点的距离，这个时候可以发现深度为 $d$ 的点的父亲就是深度为 $d-1$ 的点的父亲（正如前文所述，不要忘记链的情况每个点深度互不相同！）。
知道了这一点就可以随便怎么搞了，我的做法是根据深度小到大排序。这里不必赘述。
测试数据 9~11 从这里开始我们将走向玄学和魔法的道路。</description>
    </item>
    
    <item>
      <title>大师 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E5%A4%A7%E5%B8%88-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Wed, 26 Aug 2020 21:37:24 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E5%A4%A7%E5%B8%88-%E9%A2%98%E8%A7%A3/</guid>
      <description>题目传送门
1 题目介绍 本题的大意就是在一个序列 $a$ 中，求删去若干个数字，使得剩下的数字是等差数列得方法数，从动态规划的角度，这是标准的计数类 DP。
最后的数据也告诉我们时间复杂度是 $\operatorname{O}${$nv$} 或 大约 $\operatorname{O}${$n^2$} 的。
2 解析 2.1 开端 猎奇解法的开端：勇于尝试
对于等差数列，最显著的特征就是公差相等。我的想法是首先计算出任意两个数字的差（显然是平方复杂度），再研究有什么 好 算 法 。
假设 $c_{i,j}$ 表示 $a_i-a_j$，对于样例$1$ 的数据（注：后文所有的举例推导都是来自样例$1$ 的数据）：
 8
  13 14 6 20 27 34 34 41
 手算（也可以电脑算）很容易得出这样的关于 $c$ 数组的表：

在这个表里面，找到了两个特点：
 该表的左上到右下的对角线格子（即所有 $c_{i,i}$）都是 $0$； 以该线为对称轴，对称的两个格子的数互为相反数。  主要利用的是第二个特点，这样子就没有必要求出整个 $c$ 数组，只需要求一半（这里选择哪一半形都行，这里我选择右上的这一半）。
其次还是利用第一个特点，这样子就不需要存储一个对角线的 $0$ 了，那么在我存储的内容中，对于坐标 $(i,j)$，一定有 $i&amp;gt;j$。
2.2 核心算法 既然等差数列的公差相等，也就是说在这个 $c$ 数组里面，数值一样的几个地方可以作为等差数列的一部分。
这句话非常不好理解，我举个例子好了：$c_{1,4}$ 和 $c_{4,5}$ 可以作为等差数列，还原到输入的 $a$ 数组里面，对应的就是 $13,20,27$ 三个数。同样第五行的两个 $7$ 也可以进来，但是注意同一行的多个可行方案（公差不是 $0$）只能选择入一个，这是为什么呢？</description>
    </item>
    
    <item>
      <title>贴海报 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E8%B4%B4%E6%B5%B7%E6%8A%A5-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Thu, 06 Feb 2020 21:47:47 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E8%B4%B4%E6%B5%B7%E6%8A%A5-%E9%A2%98%E8%A7%A3/</guid>
      <description>题目传送门
这道题题解里各位都用的线段树、浮水法，本蒟蒻完全不会，这里给出我的方法，既没有线段树也没有浮水法，较为易懂（?）。
可以发现$n$的范围极其大，但是$m$的范围很小，只有1000，所以可以想到一个大致为$m^2$的算法。
假设输入顺序代表时间顺序，一行为一天（这样好理解）
每当一张海报贴到墙上时，只需要知道这张海报对以前贴的海报造成了什么影响即可。
具体修改方法：通过修改一张海报左端点右端点位置实现。
假设一张海报左端点为$l_i$，右端点为$r_i$
（注：下列图中红色表示以前贴的海报，蓝色表示今天贴的海报）
 情况一：完全覆盖，如图。  可以专门设计一个bool数组，$u_i=1$表示这个海报没有用了。
 情况二：毫不相关，如图。  这时我们不用管就行。
 情况三：覆盖了左边部分，如图。  此时要将红色海报的左端点挪到蓝色海报右端点的右边。
因为红色海报的地盘被蓝色海报盖掉了一部分，那一部分已经不再是红色海报的地盘了，可以视为红色海报本来就没有这个地盘。
 情况四：覆盖了右边部分，如图。  将红色海报的右端点挪到蓝色海报左端点的左边。
 情况五，也是最麻烦的，刚好劈开了以前的海报，如图。  这时候我们可以视为这个红色海报不再是一个整体了，而是变成了颜色相同的两张海报。
第一张海报的$l_j$还是原来的红色海报的$l_i$，而$r_j$变成了蓝色海报左端点的左边。
第二张海报的$l_k$变成了蓝色海报右端点的右边，而$r_k$还是原来的红色海报的$r_i$。
为了避免统计时认成两张不同的海报，我们还需要一个数组$d$，$d_i$来标记它的颜色，多张海报颜色相同就视为这些海报是同一张海报。
到这里，每张海报的信息点就出来了，$l$表示左端点位置，$r$表示右端点位置，$u$表示是否永远离开了这面墙，$d$表示颜色。
因为我们随时有可能在增加新海报，海报总数是不可估量的，所以要用C++的STL中的vector
如果不清楚vector的话，直接把他理解成一个可以自动伸缩长短的数组，有一个叫push_back的函数可以在这个数组后面挤进去一个数。
struct photo{ int l,r,d; bool u; }; vector&amp;lt;photo&amp;gt; a; 下面的码风过丑，需要逐行理解。
for(register int i=1;i&amp;lt;=m;++i){ photo p; s=a.size(); //因为海报总数不一定是m了（情况五会增加海报数），所以需要实时更新海报数量  p.l=read(); p.r=read(); p.d=i;// 第i个海报颜色标记为i，绝对就不会搞混了  p.u=0;//刚贴的海报不可能全被覆盖  // 贴海报前需要审核，看看这张海报造成的影响  for(register int j=s-1;j&amp;gt;=0;--j) if(!a[j].u){ // 如果这张海报已经阵亡就跳过  if(p.</description>
    </item>
    
    <item>
      <title>ぶんたん 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E3%81%B6%E3%82%93%E3%81%9F%E3%82%93-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Wed, 15 Jan 2020 21:32:54 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E3%81%B6%E3%82%93%E3%81%9F%E3%82%93-%E9%A2%98%E8%A7%A3/</guid>
      <description>题目传送门
本题没有样例，这里随便先给四个样例供各位测试，一个正常样例，两个特殊样例，一个大样例：
样例1： $in:$ 30，$out:$ 3
样例2： $in:$ 13，$out:$ 1
样例3： $in:$ 1，$out:$ 1
样例4： $in:$ 314159265，$out:$ 11
都能过就差不多了
 看到“同一个数可以使用多次”就可以推测出这题是贪心了。
不然$10^{10}$的数据你也不好$DP$，再说这道题很明显就具备贪心选择性。
这道题可以直接推出来斐波那契数列，反正复杂度不高。
不过既然斐波那契数列递推不是很麻烦，所以可以提前打表，避免毒瘤出题人出的卡常数优化的数据。
虽然这道题不需要表，但这是一个技巧，考试可以用到。
所以先贴上打表代码：
#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; long long f[65]; int main(){ f[0]=f[1]=1; printf(&amp;#34;1,1,&amp;#34;); for(register int i=2;i&amp;lt;65;++i){ f[i]=f[i-1]+f[i-2];	//斐波那契递推公式  printf(&amp;#34;%lld,&amp;#34;,f[i]); } return 0; } 把表运行一下，简单整理即可
现在来处理贪心策略：
既然我要让最终结果，也就是选的数量尽量少，该怎么办呢？
结论是：每次选择中选数字尽量大的。
本来这里想写我不会证的，本着做良心题解的观念，我摸索出了大致的证明：
 证明：
首先直接上$\color{purple}\text{齐肯多夫定理}$：
齐肯多夫定理表示任何正整数都可以表示成若干个不连续的斐波那契数（不包括第一个斐波那契数）之和。这种和式称为齐肯多夫表述法。
齐肯多夫表述法可以通过贪心得到：每次选最大的。 现在证明为什么这样是个数最小的：
假设有两个数相邻：
直接$f_{i}+f_{i+1}=f_{i+2}$ 合并。
所以不是齐肯多夫表述法的分解方法一定不是最小的。
继续证……
假设一个斐波那契数$m$，在不超过$m$的斐波那契数中选若干不连续的，最大和是多少呢？
举个例子，$m=13$。在$1,1,2,3,5,8$里面怎么选呢？当然是$8+3+1=12$。
这是一个简单的结论，在不超过$m$的斐波那契数中选若干不连续的，最大和是$m-1$
所以一个数$i$，我想找到它的$2$种齐肯多夫表述法，现已用贪心找到一种。
假设贪心出来要分$f_{j}$，但我不想分$f_{j}$，那么剩下的分法中，最大和是？
当然是$f_{j-1}+f_{j-3}+f_{j-5}+&amp;hellip;&amp;hellip;+1$。
这一坨加起来是$f_{j}-1$。</description>
    </item>
    
    <item>
      <title>花生采摘 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Sat, 11 Jan 2020 10:39:25 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E8%8A%B1%E7%94%9F%E9%87%87%E6%91%98-%E9%A2%98%E8%A7%A3/</guid>
      <description>题目传送门
翻了这道题的前两页题解，没有几个和我的思路相仿的。唯一的一个我看不懂
首先为了让大家快速找到自己可能有的错误，把这道题的部分坑点给出来：
 关于算法，题目已经明确规定了走法是按照花生数目由大到小摘花生：  鲁宾逊先生说：“你$\color{red}\text{先找出花生最多}$的植株，去采摘它的花生；然后$\color{red}\text{再找出剩下的植株里花生最多的}$，去采摘它的花生；$\color{Blue}\text{依此类推}$，不过你一定要在我限定的时间内回到路边。”
 关于摘花生，将花生采摘下来是要耗费时间的。有同学没有+1，就会爆炸。
  关于抄近道，题目虽然没有说清楚，但是不能通过在大路上抄近道省时间。
  比如这样的情况，不能走红线，只能老老实实走蓝色路（曼哈顿）
关于第四个数据点：  1 1 5
15
如果你的答案是 45，请检查一下你是否重复在摘这个仅有的格子。
 关于数组大小：开25*25绝对不会错。
  对于没读好题目：保证没有花生数一样的格子，各位不要想太多。
  考虑最终答案是0的情况，不要一上来就摘了花生回不去。
  无脑抄袭我的代码或其他有反作弊措施的代码的人会体验CE的快感。
  然后是我对这道题的分析：
做法比较明显，就是一步一步摘，判断会不会超时，然后算一个曼哈顿距离。
（曼哈顿距离公式：|$x_{1}$-$x_{2}$|+|$y_{1}$-$y_{2}$|）
各位的算法基本都是使用一个结构体，存储格子的坐标和花生数，有的人还存了时间，然后 sort 结构体，依次考虑摘不摘。
我的方法主要区别是省去了结构体和排序这两步。
我使用了一个 map（套 pair） 来存储一个格子的花生数目和坐标，这样当我选定一个花生数目的时候可以 O(1) 查询坐标。
对于从大到小排序，C++ 的STL的 $\color{RoyalBlue}\text{priority queue}$ 可以 O(logn) 插入一个数。
使用 STL 就可以做到输入完成的时候就已经做好了花生数和坐标的绑定，以及一个排序。
这个算法坑在代码实现，最难的地方就是怎么拼写 $\color{RoyalBlue}\text{priority queue}$
解决方法也很简单，搜一下就可以了
$\color{LimeGreen}\text{输入代码}$
int n,m,k,a[23][23]; map&amp;lt;int,pair&amp;lt;int,int&amp;gt; &amp;gt;c; priority_queue&amp;lt;int&amp;gt; q; n=read(),m=read(),k=read(); for(register int i=1;i&amp;lt;=n;++i) for(register int j=1;j&amp;lt;=m;++j){ a[i][j]=read(); c[a[i][j]]=make_pair(i,j); q.</description>
    </item>
    
    <item>
      <title>BITMAP 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/bitmap-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Tue, 27 Aug 2019 21:32:18 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/bitmap-%E9%A2%98%E8%A7%A3/</guid>
      <description>最近总喜欢在SPOJ上刷黑白双煞题
题目传送门
这题的思路异常简单。实际上，如果你稍微看一看，就会发现……
$\color{CornflowerBlue}\text{范围：1&amp;lt;=n,m&amp;lt;=182}$
所以很多人第一反应想到的就是暴力搜索啊！
 只需要输入+搜索就可以搞定啊！  $\color{Green}\text{想法很完美，实际很崩溃}$
虽然我没试过，但是大概算一下，搞不好最坏要：T 组数据 · 矩阵大小 · 矩阵大小 （枚举0、1两格）
矩阵长和宽为182的范围感觉还是吃不消的。
所以就需要进一步优化。
其实具体也还是很简单的：
  既然我们枚举的是0、1两格的位置……
  $\color{CornflowerBlue}\text{不妨直接记录下来，岂不美哉？}$
  具体记录也很简单，输入时加个 if-else 就可以了。如果怕空间浪费的话，可以用 STL 的 vector ，动态延长数组，在此基础上的访问和末尾添加元素也和数组一样是 O(1) 的。
 回到正题，如果记录下来了每个0和1的位置，就只需要枚举位置就行了。大概可以优化到 O(T * n$^{2}$)。（T是数据组数）
最后乘上数据数量，虽然 T 的范围我没有找到，但实测得出这是不会TLE的。
或许就可以打出代码了……
#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; int T,n,m,i,j,b[190][190],s; bool a[190][190]; char x; vector&amp;lt;int&amp;gt; z[2]; vector&amp;lt;int&amp;gt; w[2]; int main(){ ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin&amp;gt;&amp;gt;T; while(T--&amp;gt;0){ cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for(i=1;i&amp;lt;=n;i++) for(j=1;j&amp;lt;=m;j++){ cin&amp;gt;&amp;gt;x; if(x==&amp;#39;0&amp;#39;) a[i][j]=0; else a[i][j]=1; if(!</description>
    </item>
    
    <item>
      <title>最大子段和 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Tue, 20 Aug 2019 10:49:51 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C-%E9%A2%98%E8%A7%A3/</guid>
      <description>又来水题解了
** 题目传送门**
又是一道经典的 dp
实际上这题也没有大家想的辣么难啊……
首先还是从不同的算法分析吧：
- 暴力 爆搜这代码简单直白。实际上我们需要枚举l和r，然后计算[l,r]的元素和就阔以了。
** $\color{purple}\text{代码五分钟，运行两小时}$ **
所以我们需要一个更高效的算法。
 $\color{red}\text{推导一下：}$ 首先，我们现在纸上写一写：
** 2、-4、3、-1、2、-4、3。答案4（选3、-1、2）**
那么是怎么推出来的呢？
首先看到第一个数，是$\color{green}\text{2}$。
$\color{green}\text{2}$后面是$\color{green}\text{-4}$，所以如果$\color{green}\text{-4}$是答案的一部分，那么$\color{green}\text{2}$一定也要加上去（答案就增加了）
随后是$\color{green}\text{3}$。
如果$\color{green}\text{3}$把前面的$\color{green}\text{2}$和$\color{green}\text{-4}$加上去，结果是$\color{brown}\text{1}$。这个时候反而比原来的$\color{green}\text{3}$要小了。所以如果答案含有$\color{green}\text{3}$，就一定不会加上前面的$\color{green}\text{2}$和$\color{green}\text{-4}$。
下一个数是$\color{green}\text{-1}$。这个数加上前面的$\color{green}\text{3}$之后增加了数值（变成了$\color{brown}\text{2}$），所以如果答案有$\color{green}\text{-1}$，辣么绝对还有前面的$\color{green}\text{3}$。
接下来是$\color{green}\text{2}$，如果$\color{green}\text{2}$加上前面的序列$\color{green}\text{（3、-1）}$，辣么它的值变为$\color{brown}\text{4}$。比原先增加了。
然后是$\color{green}\text{-4}$，如果把$\color{green}\text{-4}$加上前面的序列$\color{green}\text{（3、-1、2）}$，结果会变成$\color{brown}\text{0}$，比原先的$\color{green}\text{-4}$大，所以如果$\color{green}\text{-4}$是答案的一部分，那么前面的三个数也一定是答案的一部分。
最后一个数，也就是$\color{green}\text{3}$，如果将$\color{green}\text{3}$加上前面的序列，结果变成了$\color{brown}\text{3}$。
最后我们来看一看刚推导的结果，发现$\color{brown}\text{4}$是我们可以得出的最大和。
故输出4
所以说了这么多 （还用了这么多Markdown改颜色） ，最终的结果是什么呢？
$\color{DarkOrchid}\text{- 第一个数为一个有效序列}$ $\color{DarkOrchid}\text{- 如果一个数加上上一个有效序列得到的结果比这个数大，那么该数也属于这个有效序列。}$ $\color{DarkOrchid}\text{- 如果一个数加上上一个有效序列得到的结果比这个数小，那么这个数单独成为一个新的有效序列}$
在处理的过程中计算有效序列的所有元素之和。
最后取最大值即可。
（如果还有人不懂，我也只能贴代码了）
#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; int n,a[200020],b[200020],i,ans=-2147483647; int main(){ cin&amp;gt;&amp;gt;n; for(i=1;i&amp;lt;=n;i++){ cin&amp;gt;&amp;gt;a[i]; if(i&amp;lt;2) b[i]=a[i]; else b[i]=max(a[i],b[i-1]+a[i]); ans=max(ans,b[i]); } cout&amp;lt;&amp;lt;ans; return 0; } 这个代码之所以我没有加注释，是因为……
$\color{Purple}\text{还可以做得更好}$
我们来看一眼代码：
 输入a[i] 给b[i]赋值 给ans赋值  全程中 a 数组是没有意义的，也就是说，它可以被一个变量代替。</description>
    </item>
    
    <item>
      <title>数字三角形 题解</title>
      <link>http://walker68145.github.io/Arahc.github.io/posts/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E9%A2%98%E8%A7%A3/</link>
      <pubDate>Mon, 19 Aug 2019 21:47:13 +0800</pubDate>
      
      <guid>http://walker68145.github.io/Arahc.github.io/posts/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-%E9%A2%98%E8%A7%A3/</guid>
      <description>题目传送门
听说这是经典dp
于是乎我用了贪心 记忆搜索
在贴代码之前还是讲一讲吧。
- dp、分治、递归、递推、搜索 的关系 很简单，没有关系 dp 是递推，是搜索的改版，是递归的进化体，是（在死亡的边缘大鹏展翅）分治的体现。
- 详解 水题解 数字三角形 首先排除贪心。
为什么？
看一眼样例吧，的确木有贪心策略。
但是，我们可以使用搜索愉快地玩耍。
那么具体怎么搜索呢？（好问题，我也不知道）
#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; int r,a[1010][1010],i,j,ans; void dfs(int h,int l,int s){ if(h==r){ ans=max(ans,s); return; } dfs(h+1,l,s+a[h][l]); dfs(h+1,l+1,s+a[h][l]); } int main(){ memset(dp,-1,sizeof(dp)); cin&amp;gt;&amp;gt;r; for(i=0;i&amp;lt;r;i++) for(j=0;j&amp;lt;=i;j++) cin&amp;gt;&amp;gt;a[i][j]; dfs(0,0,0); return 0; } 这就是最水的深搜（爆搜），不给注释了
不用试了，我交过，TLE*4。
 神奇的记忆化 这也很简单。首先记忆化一定满足：
 函数返回值仅与其参数有关 相同参数下的返回值相同 以返回值传递结果 有一个记忆数组（滑稽）  辣么，我们的答案就会要以返回值传递。
具体的思路也很简单，只要 洗洗睡吧其实要改很多 调整一下思路，你就会发现：
答案居然是 max(左边路的最大分数,右边路的最大分数)+自己的数 如果你还要问为什么，我也会 严肃 地回答你：
这里的左边路、右边路不是指一直向左走向右走，是本次左走之后所有的可以走的路（右边也一样）。
所以这也是显而易见的</description>
    </item>
    
  </channel>
</rss>
